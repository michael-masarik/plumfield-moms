/**
 *
 * @param {Object} options
 * @param {string} parent - The ID of the parent page or database.
 * @param {string} parent_type - "page_id" or "database_id".
 * @param {(Array<Object>|Object)} pages - an array of simple objects, each of which will be turned into a valid page object. Each can have property types that match to valid Notion page properties, as well as a "cover", "icon", and "children" property. The "children" prop's value should be either a string or an array. You can also pass a single object, but the function will still return an array.
 * @param {Object} schema - an object that maps the schema of the pages objects to property names and types in the parent. Saves you from needing to specify the property name and type from the target Notion database for every entry in your pages object. For each property in your pages object that should map to a Notion database property, specify the key as the property name in the pages object and set the value as an array with the Notion property name as the first element and the property type as the second. Non-valid property types will be filtered out. Optionall, you can specify custom keys for the icon (["Icon", "icon"]), cover (["Cover", "cover"]), and children array (["Children", "children"]).
 * @param {function} childrenFn - a callback you can specify that will run on any array elements present in a "children" property of any object in the pages array. If that "children" property contains a single string, it'll run on that as well. If omitted, any "children" values will be converted to Paragraph blocks by default.
 *
 * @example
 * const database = "abcdefghijklmnopqrstuvwxyz"
 *
 * const tasks = [ {
 *   icon: "ðŸ˜›",
 *   task: "Build Standing Desk",
 *   due: "2024-09-10",
 *   status: "Not started"
 * } ]
 *
 * const schema = {
 *   task: [ "Name", "title" ],
 *   due: [ "Due Date", "date"],
 *   status: [ "Status", "status" ]
 * }
 *
 * const pageObjects = quickPages({
 *      parent: database,
 *      parent_type: "database_id",
 *      pages: tasks,
 *      schema: schema,
 *      childrenFn: (value) => NotionHelper.makeParagraphs(value)
 * })
 * @returns {Array<Object>} - An array of page objects, each of which can be directly passed as the children for a POST request to https://api.notion.com/v1/pages (or as the single argument to notion.pages.create() when using the SDK).
 */
export function quickPages({ parent, parent_type, pages, schema, childrenFn }: Object): Array<Object>;
/**
 * A builder object for Notion content.
 * @typedef {Object} NotionBuilder
 */
/**
 * A factory function that provides methods for building Notion objects, including pages, properties, and blocks. It adds an unhealthily-large spoonful of syntactic sugar onto the Notion API.
 *
 * Returns an object with two possible properties:
 *
 * 1. content (always returned) - can be a full page object, an array of blocks, or a properties object.
 *
 * 2. addititionalBlocks - array containing arrays of blocks passed to the builder function that go over Notion's limit for the number of blocks that can be in a children array. This allows you to add these to the returned page or block in further requests.
 *
 * This builder supports chaining methods so you can build pages or structures incrementally. It also supports block-nesting with the startParent() and endParent() methods.
 *
 * After adding all your blocks and properties, call build() to return the final object. It can be passed directly as the data object in Notion API requests.
 *
 * @namespace
 * @function createNotion
 * @param {boolean} [strict=false] If true, the builder will throw errors when passed invalid or null data. Otherwise, it will try to gracefully return, and strip out, null properties and blocks.
 * @param {number} [limitNesting=true] If true, limits the number of nested children block arrays to 2, which is the limit for a single Notion API request. Can be set to false if you're using the appendBlocks() or createPage() functions, which will recursively append nested children block arrays in subsequent API calls.
 * @param {boolean} [limitChildren=true] If true, the final content object's children array will have a maximum of 100 blocks, and the rest will be put into the additionalBlocks array in chunks of 100. If false, the content object will contain all child blocks.
 * @param {boolean} [allowBlankParagraphs=false] If true, calling .paragraph("") will result in an empty paragraph block being added to the block stack. Otherwise, .paragraph("") will return null, and will be stripped out of the children block array once you call .build()
 * @returns {NotionBuilder} A builder object with methods for constructing and managing Notion content. The builder includes methods to set page and property details, add various block types, manage nested structures, and ultimately build Notion-compatible objects.
 *
 * @example
 * const notionBuilder = createNotion();
 *
 * // Build a new Notion page with various blocks
 * const result = notionBuilder
 *   .parentDb('database-id')
 *   .title('Page Title', 'Hello World')
 *   .paragraph('This is the first paragraph.')
 *   .heading1('Main Heading')
 *   .build();
 *
 * // Access the built content and handle additional blocks if they exist
 * console.log(result.content);  // The main Notion page content
 * console.log(result.additionalBlocks);  // Any blocks that need separate requests due to size constraints
 *
 * // Create a page in Notion with the result (assumes you've installed and imported the Notion SDK and instantiated a client bound to a 'notion' variable)
 * const response = await notion.pages.create(result.content)
 */
export function createNotion({ strict, limitNesting, limitChildren, allowBlankParagraphs, }?: boolean | undefined): NotionBuilder;
/**
 * A builder object for Notion content.
 */
export type NotionBuilder = Object;
//# sourceMappingURL=pages.d.mts.map